---
title: 'Steps & Tasks' 
summary: The functional units of Orquestra.
weight: 4
---

## Overview

In contrast to a [component](../../quantum-engine/components/) declaration, a step declaration is the invocation of a task which uses one or more components. When defining a task in your workflow, you must pass the required `arguments` declared by the component.

- steps is a collection of tasks with possible dependencies among them
- a task is uses one or more components to accomplish its work

The example below shows how steps would be defined in a workflow:

```YAML
steps:
- name: getBioData # the name of the task
  config:
    runtime:
      language: python3 # the language used to run this task
      imports: [hellov1, hellov2] # the name of the component that is used by this task
      parameters:
        file: hellov1/src/python/orquestra/main.py # the file for the entrypoint used 
        function: main # the entry function to envoke
    resources: # the resources requested to run this task (optional)
      cpu: "1000m" # default cpu value
      memory: "1Gi" # default memory value
      disk: "10Gi" # default disk value
  inputs: # the arguments to pass into the entrypoint
  - name: "John Doe" # set var called name to string value "john doe"
    type: string
  - year: 1992 # set var called year to int value 1992
    type: int
  outputs: # one or more outputs from  the task
  - name: bio-data # the name of a file generated by the entrypoint used
    type: json
```

### Name

The `name` field is typically a human-readable name that can be used to reference a step. 

Step references are important because they allow us to pass artifacts produced by a certain step to the input of another. Since the step name is used to reference a specific step, it must be a unique name. For more information about how to reference the output of a given step, check out the "Referencing Step Outputs" section below.

### Arguments

The `arguments` section is where we declare the values of input parameters and input artifacts for the chosen component. Both fields are optional depending on whether or not the component requires input parameters and/or artifacts. 

#### Parameters

Parameters are typically simple values (e.g. strings, integers, floats, etc) that we can configure easily in our workflow.

##### The "resources" parameter

The `resources` parameter is a required value when calling any template that is defined outside of the current workflow file or **resource template** that uses external source code. It is used to both tell our workflow compiler where your template exists, as well as to install the necessary components that you would like to be accessible in your step at runtime.

For example, in the [Simulating Hâ‚‚ with VQE](../../tutorials/simulate-h2-with-vqe/) tutorial, the `create-molecule` step references both the `diatomic-molecule` component and the `open-pack-core` component. The `diatomic-molecule` component contains the template definition as well as source code, however, it also references source code in `open-pack-core`, so we have to declare it as a component as well.

#### Artifacts

Artifacts are the more complex data structures used by Orquestra. Check out our section on [Artifacts](../../data-management/workflow-artifacts/) for more information about them from a data management perspective. 

In this section of a step, we must declare the specific artifacts that we want to use in the current step. It is currently only possible to use artifacts produced by the execution of the current workflow. These must be referenced by name. 

See the sections "Referencing Step Outputs" and "Referencing component Inputs" to see the different ways to reference the values for artifacts.

##  Additional Functionality 

### Referencing Step Outputs

In workflows, it is often the case that we want to pass the output artifact of one step as the input into the next. This allows us to perform more complex operations on our data while also maintaining the maximum amount of data for data analysis.

In the example below, we have a component consisting of two steps. `step1` produces an output artifact called `artifact1` which is then used as the input to `step2`.

```YAML

  - name: example-component
    steps:
    - - name: step1
        component: component1
        arguments:
          parameters:
          - resources: [component1-resource]
    - - name: step2
        component: component2
        arguments:
          parameters:
          - resources: [component2-resource]
          artifacts:
          - input-artifact:
                from: "{{steps.step1.outputs.artifacts.artifact1}}"
```

As shown above, we use the syntax: `"{{steps.<step name>.outputs.artifacts.<artifact name>}}"` to reference the output artifact of a certain step. 

### Referencing component Inputs

In addition to referencing artifacts produced by other steps, sometimes we want to pass an artifact to a workflow component and then use it in one or more of that components steps. 

In the example below, we have a component that declares an input artifact called `component-input-artifact`. Then, `step1` and `step2` both use that input artifact as an input to the components they each call.  

```YAML
  - name: example-component
    inputs:
        artifacts:
        - name: component-input-artifact
    steps:
    - - name: step1
        component: component1
        arguments:
          parameters:
          - resources: [component1-resource]
          artifacts:
          - input-artifact:
                from: "{{inputs.artifacts.component-input-artifact}}"
    - - name: step2
        component: component2
        arguments:
          parameters:
          - resources: [component2-resource]
          artifacts:
          - input-artifact:
                from: "{{inputs.artifacts.component-input-artifact}}"
```

As shown above, we use the syntax: `"{{inputs.artifacts.<artifact name>}}"` to reference the input artifact of the current component. 

We are also not limited to referencing input artifacts in this manner. You can reference input parameters using a similar syntax: `"{{inputs.parameters.<parameter name>}}"`

```YAML
  - name: example-component
    inputs:
        parameters:
        - name: component-input-parameter
    steps:
    - - name: step1
        component: component1
        arguments:
          parameters:
          - resources: [component1-resource]
          - input-parameter: "{{inputs.parameters.component-input-parameter}}"
```

### Looping Over Steps

In Orquestra's workflow language we have the ability to perform a loop over a certain step, optionally passing different inputs during each iteration. 

To perform a loop, we add the `withItems` attribute to the step we want to loop over. It should be noted that there are two equivalent ways to define the `withItems` attribute. Both are shown below.

Option 1
```YAML
  - name: example-loop
    steps:
    - - name: step-to-loop-over
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
        withItems: [1, 2, 3, 4]
```

Option 2
```YAML
  - name: example-loop
    steps:
    - - name: step-to-loop-over
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
        withItems:
        - 1
        - 2
        - 3
        - 4
```

We can also reference the value of the "item" of the current iteration in our step. The syntax for this is shown below where we set the value of the `name` to the value of the "item" for the current iteration.  

```YAML
  - name: example-loop
    steps:
    - - name: step-to-loop-over
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
          - name: "{{item}}"
        withItems: ["Bob", "Alice"]
```

___
**Note:** All loops are performed in parallel by default
___

### Serial Steps vs Parallel Steps

In Orquestra, we also have the capability to control which steps in a component are performed in parallel and which are performed serially. By having this control, we enable workflows to take advantage of the distributed nature of Orquestra - allowing you to get your results quicker. To show how to control your step scheduling, let's take a look at some examples.

#### Example 1: Serial Scheduling

To ensure that steps are performed serially, you must ensure that each step has two `-`'s before the name field.

```YAML
  - name: serial-example
    steps:
    - - name: step-1
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
    - - name: step-2
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
```

In the above example, `step-1` and `step-2` both have two `-`'s and therefore `step-2` will not begin to execute until `step-1` has finished.

#### Example 2: Parallel Scheduling

To allow a set of steps to be performed in parallel, the syntax becomes as follows: the first step in the set of parallel steps still needs two `-`'s, however, all other steps in the set should only have one `-`. 

```YAML
  - name: parallel-example
    steps:
    - - name: step-1
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
      - name: step-2
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
      - name: step-3
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
```

In the above example, `step-1`, `step-2`, and `step-3` are all performed in parallel with each other.

#### Example 3: Mixed Scheduling

Often it is the case that we want a step in a component to perform only after all steps in a set of parallel steps have finished. See the example below for how to define this properly.

```YAML
  - name: mixed-example
    steps:
    - - name: serial-step-1
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
    - - name: parallel-step-1
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
      - name: parallel-step-2
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
      - name: parallel-step-3
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
    - - name: serial-step-2
        component: example-component
        arguments:
          parameters:
          - resources: [example-resource]
```

In the above example, the steps execute in the following order: 
1. `serial-step-1` begins
2. `serial-step-1` finishes
3. `parallel-step-1`, `parallel-step-2`, and `parallel-step-3` all begin executing
4. `parallel-step-1`, `parallel-step-2`, and `parallel-step-3` all finish executing (it is entirely possible for one of these steps to finish before another begins)
5. `serial-step-2` begins
6. `serial-step-2` finishes
