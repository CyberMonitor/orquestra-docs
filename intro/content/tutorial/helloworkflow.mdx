---
title: 0. Hello Workflow
description: Start here to learn how to build workflows with Orquestra.
---

## Introduction

This tutorial will cover the key components in a Quantum Engine workflow and walk you through the process of building your first workflow.

## Concepts
Every workflow is built with a `spec` that executes `templates`. A `template` is a step in the workflow that describes the context of the work to be done e.g. the code to be executed, the inputs and outputs. Templates are distributed via `resources`, which represent a versioned set of templates from an external source.

### Templates

The functional unit of a workflow is a template. Each template can do one of three things:

1. It can reference another template and provide values for any required inputs to that template.

1. It can reference code that will take in those inputs and generate outputs.

1. It can contain a list of templates.

Templates can be defined once and reused multiple times within a workflow. Templates are analogous to functions, which can execute a task or call other functions.

### Resource

Resources are a way of making templates and code reusable and shareable. A resource is made of two components: the code that will be executed and the template that calls that code. Currently, only Python 3.7 code is supported.

## Building a Workflow

There are three steps to building a workflow:

1. Create one or more templates and associated source code (optional)

1. Make templates and code available as a resource (optional)

1. Incorporate the resource into a workflow

Note: Steps 1 and 2 are optional if you reuse existing resources.

## Hello Workflow

Let's put these concepts into practice by building our first workflow. In this tutorial we will be:
- Building a resource. A new resource will let you incorporate existing code into the workflow
- Writing templates that utilize resources to create in the `step` of a workflow

We could create a very minimalistic workflow without using resources, but we would miss out on what makes Quantum Engine powerful: sharing reusable templates and code. We will start by showing you how to build your own resource.

### Building a Resource

**1. Create a GitHub repository**

Go to [GitHub](https://github.com/) and create a public repository called `welcome-resource`. If you are unfamiliar with GitHub you can reference their [create a repo guide](https://help.github.com/en/github/getting-started-with-github/create-a-repo) for help

This repository will be where you build your resource. [This GitHub repo](https://github.com/zapatacomputing/tutorial-0-welcome) can be used as a reference for how `welcome-resource` should look like throughout the tutorial.

**2. Creating the Resource Folder Structure**

In order to be recognized by Orquestra, a resource must contain two folders:
- The `src/` folder which contains:
  - A setup file that is responsible for installing your code in the machine where your workflow is executed. This installation is done automatically for you.
  - Source code under a folder called `python/`.
- The `templates` folder which will hold the templates usd by code in the `src` folder.

Using either the GitHub UI or by cloning your repo and using the command line create two folders at the root level of the repository, `src/` and `templates/`

**3. Adding `welcome.py` to `src/`**

Our goal in the first part of this tutorial is to create a resource that produces an [artifact](https://www.orquestra.io/docs/dcs/data/artifacts/) with the text `Welcome to Orquestra!` when used within a workflow. 

We will start by adding some code to the `src/` folder. In general, Orquestra can support any Python source that is installable via `pip` using a `setup.py` script. 

Moving into the `src/` folder, create a folder structure `python/orquestra/` and with a python module in it called `welcome.py`. Your repo structure should now look like this:

```
.
├── src
│   ├── python
│   │   └── orquestra
│   │       └── welcome.py
│   └── setup.py
├── templates
```

Open `welcome.py` in an editor and add the following code:

```Python
"""
This module saves a welcome message.
"""

import json

def welcome():
    message = "Welcome to Orquestra!"

    message_dict = {}
    message_dict["message"] = message
    message_dict["schema"] = "message"

    with open("welcome.json",'w') as f:
        f.write(json.dumps(message_dict, indent=2)) # Write message to file as this will serve as output artifact
```

*Two important notes:*

- All artifacts must have a `schema` field. More details on artifacts are found on the [artifacts page](https://www.orquestra.io/docs/dcs/data/artifacts/).

- We create the file `welcome.json` because any output has to be saved in a file in order to be passed on to the next template or to be accessible after the workflow has completed. We will see how to pass it on to another template later in this tutorial.

**4. Initializing the Python Package**

This `welcome` package will need an initialization file. Create a file called `__init__.py` under `src/python/orquestra/` with the following code snippet:

```Python
from .welcome import *
```

**5. Adding a `setup.py`**

We need to create a `setup.py` file that lets Orquestra know how to install the `welcome.py` source code. Create a new file `setup.py` under `src/` with the following code snippet:

```Python
import setuptools

setuptools.setup(
    name                            = "orquestra",
    packages                        = setuptools.find_packages(where = "python"),
    package_dir                     = {
        "" : "python"
    },
    classifiers                     = (
        "Programming Language :: Python :: 3",
        "Operating System :: OS Independent",
    ),
)
```

In example, `name` is the name of your package. The contents of the `packages` field in this sample tells the installer to look in your repo in a folder called `python` for your package. The contents of the `package_dir` field in this sample means that the contents of the "python" folder can be imported without the python path prefix, for example, with `from orquestra import all`.


**6. Adding `templates`**

Now that we've described the code that we want the resource to execute, we'll now work defining the `welcome` template for this resource. Move into the `templates/` folder and create a new file called `welcome.yaml`.
 
**Template**

The `welcome.yaml` template is responsible for invoking the Python code that is living under `src/`. This can be done using the following snippet:

```YAML
# Every template YAML file must begin with a `spec`, without which your template won't compile.
spec:

  # The `templates` section is where you list one or more templates
  templates:

  # This is the name of the template, which is used to reference it in the workflow. This field is required.
  - name: welcome-to-orquestra

    # `generic-task` is the supertemplate that all templates (that don't contain a `steps` section) must inherit from
    parent: generic-task

    # This section is for the inputs needed to run the template. This section is required.
    inputs:

      # `parameters` represent initialization values for a template. 
      parameters:

      # The `command` parameter is required because that is what is run by `generic-task`.
      - name: command
        value: python3 main.py

      # This section creates a script called `main.py` containing the code below under `data`. It must be under the `app` directory in order for the command above to locate it.
      artifacts:
      - name: main-script
        path: /app/main.py
        raw:
          data: |
            from orquestra import welcome
            welcome()

    # This section is where output artifacts are listed. They must be listed here, or else they will get deleted when the template completes. They must be under the `app` directory in order to be saved.
    outputs:
      artifacts:
      - name: welcome
        path: /app/welcome.json
```

Let us proceed to explain the different parts of the template we just created above.

- The `spec` section: every template YAML file must begin with a `spec`, without which your template won't compile.

- The `templates` section under `spec` allows you to list all your templates under it.

- The `name` field tells the compiler the name of your template. This field is required.

- The `parent` field allows us to specify a template natively provided by the Quantum Engine as this `parent` (called `generic-task`) contains the necessary instructions as to how to execute your Python code. This is only needed because our template doesn't have a `steps` section that would have invoked other templates (we will see an example below where a `parent` field is not specified). We finally note that you cannot have multiple parents.

- The `inputs` field lists the different input data that are needed to run your template. We have two sorts of inputs: input parameters and input artifacts. Input artifacts are in general persistent (meaning they will be written to disk) which input parameters are not. In our case, we define an input artifact which is actually executable Python code that calls the Python function we wrote earlier. The aspect to pay attention to is the `command` input parameter: without it, the input artifact will never be executed. This is because `generic-task` will look for the `command` input parameter to determine if there are commands to execute. The compiler will see the `main-script` input artifact and will create to disk a file called `/app/main.py`. But `/app` is the default working directory, so in our command, we only need to specify `python3 main.py` as the value of the `command` input parameter and not `python3 /app/main.py`. And that's how you execute your own Python code using the Quantum Engine.

- The `outputs` field allows us to specify the data we expect at the end of the template's execution. Our Python script in input artfacts produced a file under `/app/welcome.json` but without output artifacts, we will have to look for the file by path all the time, and it could even be garbage collected since we never marked it as an output artifact. By specifying the file as an output artifact, we can refer to it as input artifacts in other templates.

**7. Push Your Resource**

Having added our code under `src` and defined the templates, the final structure of the resource should look something like this:

```
.
├── src
│   ├── python
│   │   └── orquestra
│   │       ├── __init__.py
│   │       └── welcome.py
│   └── setup.py
├── templates
│   └── welcome.yaml
```

Once you are satisified with your work, commit your changes and push them back up to Github

**8. Building a Workflow**

We can now build a simple workflow that uses the `welcome` resource to generate the welcome message artifact. Let's start by creating a `welcome-workflow.yaml` file with the following code:

```YAML
# Workflow API version
ZapOSApiVersion: v1alpha1

# Declares this as workflow
kind: Workflow

# List resources needed by workflow.
resources:

# A resource named `welcome` that is a public git repo. All the fields here are required except branch, which defaults to master.
- name: welcome
  type: git
  parameters:
    url: "git@github.com:<your-github-username>/<your-git-repo-name>.git"
    branch: "master"

# Data to help you easily work with your workflow
metadata:

  # Prefix for workflow ID
  generateName: welcome-to-orquestra-

# Data for running the workflow
spec:

  # Think of this as identifying the `main` function -- this tells the workflow which template to start with
  entrypoint: salutations

  # Initializing global variables for use in workflow
  arguments:
    parameters:

    # Where output data is stored -- Must be `quantum-engine` for compatibility with Orquestra data services
    - s3-bucket: quantum-engine
    # Path where output data is stored within the `s3-bucket` -- can be anything you want
    - s3-key: tutorials/welcome/

  # The steps of the workflow
  templates:

  # `salutations` is a template that just contains a list of `steps`, which are other templates
  - name: salutations
    steps:

    # This template runs the `welcome-to-orquestra` template in the `welcome` resource
    - - name: greeting
        template: welcome-to-orquestra
        arguments:
          parameters:
          - resources: [welcome]
```

- The `ZapOSApiVersion` is the workflow API version. The current version is `v1alpha1`.

- The `kind` field declares that this is a `Workflow`.

- The `resources` section is where you can list one or more resources, such as the one you just created. Currently, only Git resources are supported, so all resources will have the fields shown in this example. Resources must have a `name`. Git resources will have `git` as the `type`. The `parameters` tell Orquestra how to find the Git resource you just built. `url`, which is the URL of your repository on GitHub, is required. `branch` will tell Orquestra which branch to use, and it will default to `master`.

- The `metadata` section contains data not necessary to run your workflow but that will be needed so you can easily work with the data generated by your workflow. In our case, we have only the `generatedName` field, which will be used to generate your workflow ID and other names (that you'll see when you execute the workflow later).

- The `spec` section contains the data for running your workflow.

- The `entrypoint` tells Orquestra which step to start with.

- The `arguments` section can have `parameters` and/or `artifacts`. `parameters` are variables that can be accessed within the workflow. `s3-bucket` and `s3-key` are used by `generic-task` (discussed above) to know where to store your outputs. `s3-bucket` must be `quantum-engine` in order for Orquestra's data management services to access your data. `s3-key` can be a path of your choosing.

- The `templates` section in a workflow is where you describe, step by step, how to go from zero to your final results. You group these steps into templates so it is easier to work with them. Steps can run in parallel or in series. Series steps begin with a double dash, while parallel steps begin with a single dash. In our case, we only have a single step, so it begins with a double dash. The `name` of the template is how the `entrypoint`, discussed above, finds it. The first step, whose `name` is `welcome`, references the template `welcome-to-orquestra`, which we created earlier in our resource, using its `template` field.

**9. Adding Resources to the Workflow**

Next, we will see how to use a pre-existing resource and explore one possible pattern for a workflow with multiple steps.

For example, Zapata has a resource with a URL of `git@github.com:zapatacomputing/tutorial-0-ztransform.git`. This will transform a message you give it in a fun way.

Open up `welcome-workflow.yaml` and add a new block under `resources` after the `welcome` resource:

```YAML
# List resources needed by workflow.
resources:

# A resource named `welcome` that is a public git repo. All the fields here are required except branch, which defaults to master.
- name: welcome
  type: git
  parameters:
    url: "git@github.com:<your-github-username>/<your-git-repo-name>.git"
    branch: "master"
    
- name: ztransform
  type: git
  parameters:
    url: "git@github.com:zapatacomputing/tutorial-0-ztransform.git"
    branch: "master"
```

This pre-built resource has a template called `z-transformation` in it and associated source code. You can now use that template in your workflow. We'll do this by adding a `transform-welcome` template under `templates` in `welcome-workflow.yaml`:

```YAML
  # The steps of the workflow
  templates:

  # `salutations` is a template that just contains a list of `steps`, which are other templates
  - name: salutations
    steps:

    # This template runs the `welcome-to-orquestra` template in the `welcome` resource
    - - name: greeting
        template: welcome-to-orquestra
        arguments:
          parameters:
          - resources: [welcome]

    # This template runs the `z-transformation` template in the `ztransform` resource
    - - name: transform-welcome
        template: z-transformation
        arguments:
          parameters:
          - resources: [ztransform]
          artifacts:
          - name: message
            # This template takes in the output artifact from the `welcome` template. 
            from: '{{steps.greeting.outputs.artifacts.welcome}}'
```

- There is now a second step with a `name` of `transform-welcome`. The step `transform-welcome` calls the `template` named `z-transformation` from the pre-built resource you just added.

- The template `z-transformation` takes in an artifact as input. The input is being fully-qualified accordingly. They must be placed inside a `{{ }}` placeholder.

**10. Running the Workflow**

You are now ready to run the workflow!

* Make sure you have installed the [Quantum Engine CLI](http://localhost:8000/tutorial/hydrogen-vqe/#using-the-quantum-engine-cli)

* Log in to Quantum Engine by running `qe login -e <your-email> -s <quantum-engine-uri>` in your terminal. Contact support to register your email and/or receive the `quantum-engine-uri`.

* Submit your `welcome-workflow.yaml` by running `qe submit workflow <path/to/workflow/welcome-workflow.yaml>`**

This will return the workflow ID that corresponds to that particular execution of your workflow. The output will look like:
```Bash
Successfully submitted workflow to quantum engine!
Workflow ID: welcome-to-orquestra-d9djf
```

**11. Worfklow Progress**

The workflow is now submitted to the Orquestra engine and will be scheduled for execution when compute becaomes available.

To see details of the execution of your workflow, run `qe get workflow <workflow-ID>` with your workflow ID from the previous step substituted in.

 The output will look like:
```Bash
Name:                welcome-to-orquestra-d9djf
Namespace:           default
ServiceAccount:      default
Status:              Succeeded
Created:             Thu Mar 19 21:14:33 +0000 (5 minutes ago)
Started:             Thu Mar 19 21:14:33 +0000 (5 minutes ago)
Finished:            Thu Mar 19 21:19:49 +0000 (19 seconds ago)
Duration:            5 minutes 16 seconds
Parameters:
  s3-bucket:         quantum-engine
  s3-key:            tutorials/welcome/

STEP                                         STEPNAME                                DURATION  MESSAGE
 ✔ welcome-to-orquestra-d9djf (salutations)
 ├---✔ greeting (welcome-to-orquestra)       welcome-to-orquestra-d9djf-2235995037  5m
 └---✔ transform-welcome (z-transformation)  welcome-to-orquestra-d9djf-1289017430  13s
```

This output shows the status of the execution of the steps in your workflow.

**12. Workflow Results**

To get the results of your workflow, run `qe get workflowresult <workflow-ID>` with your workflow ID.

After a workflow runs, it takes time for the data to be processed. This results file cannot be created until the data is done being processed. Run the above command approximately every few minutes until it returns a link to download a file. This output will look like:

```Bash
Name:        welcome-to-orquestra-d9djf
Location:    http://40.89.251.200:9000/workflow-results/bb2b58b4-b25d-59e3-9fee-e7b79f0c20d5.json?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=zapata%2F20200319%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200319T212017Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&response-content-disposition=attachment%3B%20filename%3D%22bb2b58b4-b25d-59e3-9fee-e7b79f0c20d5.json%22&X-Amz-Signature=c4de1784b252fa6164aea8aa49a91bdd84c20c4dc55411e93f69a57b4ea62ac1
```

**13. Downloading the Results**

When your workflow is completed, the `workflowresult` command will provide you with a click-able link under `Location` in the console output. Click on the link to download the file

This file will look like the following (except for the comments, which were added in this tutorial for clarity):

```JSON
{
    "welcome-to-orquestra-d9djf-2235995037": { # The step that executed the `greeting` task
        "class": "welcome-to-orquestra",
        "id": "welcome-to-orquestra-d9djf-2235995037",
        "inputParam:command": "python3 main.py",
        "inputParam:cpu": "1000m",
        "inputParam:disk": "10Gi",
        "inputParam:docker-image": "zmachine_default",
        "inputParam:docker-registry": "zapatacomputing",
        "inputParam:docker-tag": "latest",
        "inputParam:memory": "1024Mi",
        "welcome": { # An artifact called `welcome`
            "id": "welcome-to-orquestra-d9djf-2235995037/welcome",
            "message": "Welcome to Orquestra!", # The message generated by this template
            "schema": "message",
            "taskClass": "welcome-to-orquestra",
            "taskId": "welcome-to-orquestra-d9djf-2235995037",
            "workflowId": "welcome-to-orquestra-d9djf"
        },
        "workflowId": "welcome-to-orquestra-d9djf"
    },
    "welcome-to-orquestra-d9djf-1289017430": { # The step that executed the `transform-welcome` task
        "class": "z-transformation",
        "id": "welcome-to-orquestra-d9djf-1289017430",
        "inputArtifact:message": "welcome-to-orquestra-d9djf-2235995037/welcome",
        "inputParam:command": "python3 main.py",
        "inputParam:cpu": "1000m",
        "inputParam:disk": "10Gi",
        "inputParam:docker-image": "zmachine_default",
        "inputParam:docker-registry": "zapatacomputing",
        "inputParam:docker-tag": "latest",
        "inputParam:memory": "1024Mi",
        "workflowId": "welcome-to-orquestra-d9djf",
        "zessage": { # An artifact called `zessage`
            "id": "welcome-to-orquestra-d9djf-1289017430/zessage",
            "message": "Zelcome Zo Zrquestra!", # The message after it was transformed
            "schema": "message",
            "taskClass": "z-transformation",
            "taskId": "welcome-to-orquestra-d9djf-1289017430",
            "workflowId": "welcome-to-orquestra-d9djf"
        }
    }
}
```

The sections `welcome-to-orquestra-d9djf-1289017430` and `welcome-to-orquestra-d9djf-2235995037` correspond to the steps that were run by your workflow. Note that these IDs match those in the output of `qe get workflow`. Each of these sections contains information about the template that was executed, and they also contain their output artifact. The artifact `welcome` is the output of the `greeting` template, and the artifact `zessage` is the output of the `transform-welcome` template. More information on the contents of this file are found on the [Workflow Results via JSON page](https://www.orquestra.io/docs/dcs/data/json/).

Note: The sections in this results file will not necessarily be in the order that they were executed.

## Summary

We have now seen how to construct a working workflow from its elemental components: workflows, templates and resources.

Additionally, we submitted a workflow to Quantum Engine and got its result in JSON format.
This hopefully introduced some of the key concepts and mechanics in using Orquestra Quantum Engine.

## Completed Tutorial Materials

For your convenience, here are the completed resources and workflow:

[Welcome resource](https://github.com/zapatacomputing/tutorial-0-welcome)

[ZTransform resource](https://github.com/zapatacomputing/tutorial-0-ztransform)

[Complete workflow](http://orquestra.io/docs/hello-workflow.yaml)