---
title: Interfaces
description: Integrating a backend or optimizer with Orquestra
---

## Introduction

One of the biggest strengths of Orquestra is its modularity. Integrating new backends, optimizers, compilers, etc. does not require changing the core code – it requires only creating a new module that conforms to existing interfaces and therefore can be used across the whole platform.

### Interfaces in Orquestra

Orequestra interfaces are defined in the [`z-quantum-core` repository](https://github.com/zapatacomputing/z-quantum-core/tree/master/src/python/zquantum/core/interfaces).

Orquestra defines the following interfaces:
- `QuantumBackend`
- `QuantumSimulator` (subclass of `QuantumBackend`)
- `Optimizer`

## Integrating Backends & Optimizers

### How to integrate your own backend / optimizer
In order to integrate a new quantum backend or optimizer into Orquestra you need to create a class which inherits after `QuantumBackend`/`QuantumSimulator` or `Optimizer`.
All you need to do is just implement the methods specified by the interface. In some cases implementing a new backend might also require installing additional software and therefore need a special docker container to work.

With optimizers, the object return should be of type `scipy.optimize.OptimizeResult` and needs to have the following fields:
- `opt_value`: the optimal value of the cost function
- `opt_params`: parameters corresponding to the `opt_value`.

### Using integration

Once you've done your integration, there are two ways you can use it in your template.
The first one is obvious – you can simply import from the module you've just created, create a python object and voila!

However, this means that the backend/optimizer will be hardcoded in your template and using another one will require changes to the template.
That's why you can use `create_object` function from `zquantum.core.utils`. It takes a dictionary with specification of the object you'd like to create and creates it inside the template. Take a look at the following example:

```yaml
templates:
- name: use-any-backend
  parent: generic-task
  inputs:
    parameters:
    - name: backend-specs
    - name: command
      value: bash main_script.sh
    artifacts:
    - name: main-script
      path: /app/main_script.sh
      raw:
        data: |
          python3 python_script.py
    - name: python-script
      path: /app/python_script.py
      raw:
        data: |
          from zquantum.core.utils import create_object
          backend_specs = {{inputs.parameters.backend-specs}}
          backend = create_object(backend_specs)
```

`backend-specs` dictionary should have the following fields:
- `module_name` - it specifies from which python module you want to import.
- `function_name` - it specifies the function you want to use to create your object.
- others - it will treat any other entries in the dictionary as keyword arguments for your object.

For example, for the `MockSimulator` it might look like this:

```yaml
- backend-specs: "{'module_name': 'zquantum.core.interfaces.mock_objects', 'function_name': 'MockQuantumSimulator', 'n_samples': 1000}"
```

### Integrated backends

Each hardware integrate lives in a separate repository:

- [qHiPSTER](https://github.com/zapatacomputing/qe-qhipster)
- Forest QVM (pending)
- qulacs (pending)


### Integrated optimizers

All the currently implemented optimizers live in the [z-quantum-optimizers repository](https://github.com/zapatacomputing/z-quantum-optimizers):

- grid search - brute-force approach checking all the values from a grid.
- scipy optimizers - integration with `scipy.minimize` optimizers.
- CMA-ES - Covariance Matrix Adaptation Evolution Strategy
